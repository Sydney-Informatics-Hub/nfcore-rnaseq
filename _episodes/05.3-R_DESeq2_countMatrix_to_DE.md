---
title: "Pre-processing of read-countmatrix with R/RStudio"
teaching: 10
exercises: 10
questions:
- "How to import a count-matrix (output from nfcore) in R?"
- "How to generate PCA/Scree plots for exploring multivariate data?"
- "How to use the DESeq2 module to perform differential expression (DE) analysis?"
- "How to visualise the results from DeSeq2 analysis?" 


objectives:
- "Use RStudio on Nimbus instance to process the count-matrix and generate a list of differentially expressed genes."

keypoints:
- XXX
---

This session shows us how to use the 'count-matrix' generated by the nfcore-rnaseq pipeline and run R programming in RStudio (Nimbus instance) to perform differential expression analysis. 


QC of count data
Multidimensional scaling plot
Density plots
Box plots
Voom variance plot
MD and Volcano plots for DE results


### Pre-processing steps

> ## Set the current working directory
> ~~~
> ## Set the current path as the current working directory
> current_path <- getActiveDocumentContext()$path 
> setwd(dirname(current_path ))
> print( getwd() )
> ~~~
> {: .language-bash}
{: .solution}

> ## Load the 'R' libraries
> ~~~
> ## Load all R packages (libraries), required for the various steps in this analysis.
> library("DESeq2")
> library("edgeR")
> library("limma")
> library("RColorBrewer")
> library("gplots")
> library("ggplot2")
> library("EnhancedVolcano")
> library("factoextra")
> library("devtools")
> library("rstudioapi")
> library("dplyr")
> library("tibble")
> library("tidyverse")
> # Bioinformatics databases/formatting etc
> library("biomaRt")
> library("annotables")
> library("org.Mm.eg.db")
> library("biobroom")
> # Functional analysis
> library("clusterProfiler")
> library("pathfindR")
> library("RColorBrewer")
> library("pheatmap")
> ~~~
> {: .language-bash}
{: .solution}

## Count matrix from nfcore-rnaseq
- The countdata file contains information about genes (one gene per row)
- The first column has the gene symbol/gene ID and the remaining columns contain aligned read counts per sample
- The combined-count matrix was generated using 'nfcore-rnaseq'
> ## Read the count matrix 
> ~~~
> counttable<-read.delim("GSE81082_count_matrix_ENSIDs_symbols_nr.txt", header=T, row.names=1)
> View(counttable)
> 
> # Why un-normalized counts?
> # As input, the DESeq2 package expects count data as obtained, e.g., from RNA-seq or another high-throughput sequencing experiment, in the form of a matrix of integer values. 
> # The value in the i-th row and the j-th column of the matrix tells how many reads can be assigned to gene i in sample j. 
> # The values in the matrix should be un-normalized counts or estimated counts of sequencing reads (for single-end RNA-seq) or fragments (for paired-end RNA-seq). 
> # The DESeq2 model internally corrects for library size, so transformed or normalized values such as counts scaled by library size should not be used as input.
> 
> View(counttable)
> 
> # Gene Symbol as identifier
> counttable<-counttable[,c("Symbol","WT1","WT2","WT3","KO1","KO2","KO3")]
> row.names(counttable) <- NULL
> 
> # Convert Column  'GeneSymbol' to rowname)
> rownames(counttable) <- counttable$Symbol
> counttable<-counttable[,c("WT1","WT2","WT3","KO1","KO2","KO3")]
> View(counttable)
> ~~~
> {: .language-bash}
{: .solution}

## DeSeq2
### The DESeqDataSet
- The object class used by the DESeq2 package to store the read counts and the intermediate estimated quantities during statistical analysis is the DESeqDataSet, which will usually be represented in the code here as an object dds.
- A DESeqDataSet object must have an associated design formula. The design formula expresses the variables which will be used in modeling. The formula should be a tilde (~) followed by the variables with plus signs between them.
- The design can be changed later, however then all differential analysis steps should be repeated, as the design formula is used to estimate the dispersions and to estimate the log2 fold changes of the model.
- There are multiple ways of constructing a DESeqDataSet, depending on what pipeline was used upstream of DESeq2 to generated counts or estimated counts
- Here we have a matrix (as read in a dataframe above) of read counts prepared from our previous analysis using nfcore-rnaseq pipeline. So we use the function - DESeqDataSetFromMatrix
> ## Create DESeqDataSet object
> ~~~
> condition=c("Wild","Wild","Wild","KO","KO","KO")
> meta <- data.frame(row.names=colnames(counttable),condition)
> View(meta)
> dds <- DESeqDataSetFromMatrix(countData = counttable,
>                               colData = meta,
>                               design = ~ condition)
> ## Pre-filtering 
> # While it is not necessary to pre-filter low count genes before running the DESeq2 functions, there are two reasons which make pre-filtering useful: by removing rows in which there are very few reads, we reduce the memory size of the dds data object, and we increase the speed of the transformation and testing functions within DESeq2. 
> # Filter to remove lowly expressed genes - keeping those with more than 1 counts per million in at least 4 / 6 samples 
> keep <- rowSums(cpm(counttable)>1) >=4
> dds <- dds[keep,]
> # Explicitly set the factors levels 
> # By default, R will choose a reference level for factors based on alphabetical order.
> # So if you never tell the DESeq2 functions which level you want to compare against (e.g. which level represents the control group), the comparisons will be based on the alphabetical order of the levels.
> # Setting the factor levels can be done in two ways
> # Using factor
> #dds$condition <- factor(dds$condition, levels = c("Wild","KO"))
> #OR
> # using relevel, just specifying the reference level:
> dds$condition ~ relevel(dds$condition, ref="Wild")
> ~~~
> {: .language-bash}
{: .solution}

### Exploratory analysis and visualization
**Data transformations**
- In order to test for differential expression, we operate on raw counts and use discrete distributions as described in the previous section on differential expression. 
- However for other downstream analyses – e.g. for visualization or clustering – it might be useful to work with transformed versions of the count data.
- The most obvious choice of transformation is the logarithm.
Types
- (1) Variance stabilizing transformation (vst)
- (2) Regularized log transformation (rlog)

> ## Principal component plot of the samples
> - Related to the distance matrix is the PCA plot, which shows the samples in the 2D plane spanned by their first two principal components. 
> - This plot is useful for visualizing the overall effect of experimental covariates and batch effects.
> ~~~
> 
> ## Scree plot
> pca=prcomp(t(assay(vsd)),scale=FALSE)
> options(repr.plot.width=0.5, repr.plot.height=0.5)
> fviz_eig(pca, addlabels = TRUE)
> <figure>
> <img src="{{ page.root }}/fig/scree.png" style="margin:10px;height:350px"/>
> </figure><br> 
> 
> ## PCA
> vsd <- vst(dds, blind=FALSE)
> z<-plotPCA(vsd, intgroup=c("condition"))
> z+ geom_text(aes_string(x = "PC1", y = "PC2", label = "name"),color = "black",size = 4)
> # There is an error with vsd (posssibly due to very few rows/ genes with valid expression)
> # https://support.bioconductor.org/p/98634/
> # problem is that your expression matrix doesn't have more than 1000 genes (rows) in it.
> # Using rlog (regularized log) transformation is slower but it works in this case for very few genes 
> #rld <- rlog(dds)
> #z<-plotPCA(rld, intgroup=c("condition"))
> #z+ geom_text(aes_string(x = "PC1", y = "PC2", label = "name"), color = "black",size = 4)
> <figure>
> <img src="{{ page.root }}/fig/PCA.png" style="margin:10px;height:350px"/>
> </figure><br> 
> 
> ## Heatmap of the sample-to-sample distances
> # A heatmap of this distance matrix gives us an overview over similarities and dissimilarities between samples. 
> # We have to provide a hierarchical clustering hc to the heatmap function based on the sample distances, or else the heatmap function would calculate a clustering based on the distances between the rows/columns of the distance matrix.
> library("RColorBrewer")
> library(pheatmap)
> sampleDists <- dist(t(assay(vsd)))
> sampleDistMatrix <- as.matrix(sampleDists)
> rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
> colnames(sampleDistMatrix) <- NULL
> colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
> pheatmap(sampleDistMatrix,
>          clustering_distance_rows=sampleDists,
>          clustering_distance_cols=sampleDists,
>          col=colors)
> <figure>
> <img src="{{ page.root }}/fig/distance_heatmap.png" style="margin:10px;height:350px"/>
> </figure><br> 
> ~~~


> {: .language-bash}
{: .solution}
