---
title: "Pre-processing of read-countmatrix with R/RStudio"
teaching: 10
exercises: 10
questions:
- "How to import a count-matrix (output from nfcore) in R?"
- "How to generate PCA/Scree plots for exploring multivariate data?"
- "How to use the DESeq2 module to perform differential expression (DE) analysis?"
- "How to visualise the results from DeSeq2 analysis?" 


objectives:
- "Use RStudio on Nimbus instance to process the count-matrix and generate a list of differentially expressed genes."

keypoints:
- XXX
---

### Pre-processing steps
> ## Set the current working directory
> ```
> current_path <- getActiveDocumentContext()$path 
> setwd(dirname(current_path ))
> ```
> {: .language-bash}
{: .solution}

> ## Load the R-libraries
> ```
> suppressMessages({
>   library("DESeq2")
>   library("edgeR")
>   library("limma")
>   library("RColorBrewer")
>   library("gplots")
>   library("ggplot2")
>   library("EnhancedVolcano")
>  library("factoextra")
>   library("devtools")
>   library("rstudioapi")
>   library("dplyr")
>   library("tibble")
>   library("tidyverse")
>   library("pheatmap")
>   library("biomaRt")
>   library("annotables")
>   library("org.Mm.eg.db")
>   library("biobroom")
>   library("clusterProfiler")
>   #library("pathfindR")
> })
> ```
> {: .language-bash}
{: .solution}


### Input to R 
- The DESeq2 package expects count data from RNA-seq or another high-throughput sequencing experiment in the form of a matrix of integer values, as input. 
  - The value in the i-th row and the j-th column of the matrix tells how many reads can be assigned to gene i in sample j. 
  - The values in the matrix should be un-normalized counts or estimated counts of sequencing reads (for single-end RNA-seq) or fragments (for paired-end RNA-seq). 
  - The DESeq2 model internally corrects for library size, so transformed or normalized values such as counts scaled by library size should NOT be used as input.
- Next, we read in the count matrix generated by the "nfcore-rnaseq" pipeline.
  - We have generated a matrix for a sub-set of the data from a specific region of the genome (chromosome 18). This was done with consideration to the time required for mapping and other processing steps involved.
  - We will be using this processed - subset matrix as part I of our analysis. This matrix should be available in the path "/".
  - As part II of the hands-on, we will redo the analysis with a FULL matrix which has been downloaded from the original manuscript. We can then use this full data for identifying gene functional categories of interest.
  - The file containing the full matrix should be available in the same folder "/" as "GSE81082_count_matrix_ENSIDs_symbols_nr.txt". 

> ## Import the gene-count matrix
> ```
> counttable_original<-read.delim("GSE81082_count_matrix_ENSIDs_symbols_nr.txt", header=T, row.names=1) 
> # View the count matrix
> #View(counttable_original)
> # Gene symbol as the identifier (when compared to ENSG ID)
> counttable<-counttable_original[,c("Symbol","WT1","WT2","WT3","KO1","KO2","KO3")]
> row.names(counttable) <- NULL
> # Convert Column  'GeneSymbol' to rowname)
> rownames(counttable) <- counttable$Symbol
> counttable<-counttable[,c("WT1","WT2","WT3","KO1","KO2","KO3")]
> #View(counttable)
> ```
> {: .language-bash}
{: .solution}


### DESeq2 object
- The object class used by the DESeq2 package is the DESeqDataSet.
- The DESeqDataSet object is used to store the read counts and the intermediate estimated quantities during statistical analysis 
- We will call this object by name 'dds' as this is a standard practice.
- Please see the [guide](http://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) for more package information.
- We will  define a condition variable to associate the individual columns (samples) in the matrix to their appropriate experimental condition (either 'Wild-type' or 'Knockout').
- We will then prepare the DESeq2 object with `design = ~1`. 
- A design of ~1 is used for no experimental design and is useful for exploring QC of the data (not for identifying differentially expressed -DE genes).

> ## Creating the DESeqDataSet object
> ```
> #Define a condition variable 
> condition=c("Wild","Wild","Wild","KO","KO","KO")
> meta <- data.frame(row.names=colnames(counttable),condition)
> #View(meta)
> dds <- DESeqDataSetFromMatrix(countData = counttable, 
                              colData = meta, 
                              design = ~1)
> ```
> {: .language-bash}
{: .solution}


### Data transformations
- For visualization or clustering it might be useful to work with transformed versions of the count data.
- The most obvious choice of transformation is the logarithm.
- (1) Variance stabilizing transformation (vst)
- (2) Regularized log transformation (rlog)
- This transforms the raw count data (which is heteroskedatic - variance grows with the mean) into homoskedatic data (variance is not dependant on the mean). 
- Both methods produce data on the log2 scale, and normalize for other factors such as library size. Setting `blind=TRUE` (the default) should be used to compare samples in a manner wholly unbiased about the information about experimental groups, for example to perform sample QC. 
- Note : In order to test for differential expression, we operate on raw counts (and not normalized/transformed counts).

> ## Variance stabilisting transformation (VST)
> ```
> #VST by default uses a subset of 1000 rows to estimate the dispersion trend. This method is much faster than rlog, and is recommended if you have hundreds of samples.
> vst <- vst(dds, blind = TRUE)
> vst.data <- assay(vst)
> # Regularized log (rlog) takes a long time with 50 or more samples
> # rld <- rlog(dds, blind=FALSE)
> ```
> {: .language-bash}
{: .solution}

### Sample-to-sample distances
- A heatmap of this distance matrix gives us an overview over similarities and dissimilarities between samples. 
- We have to provide a hierarchical clustering hc to the heatmap function based on the sample distances, or else the heatmap function would calculate a clustering based on the distances between the rows/columns of the distance matrix.

> ## Heatmap to show sample-distances
> ```
> sampleDists <- dist(t(assay(vst)))
> sampleDistMatrix <- as.matrix(sampleDists)
> rownames(sampleDistMatrix) <- paste(vst$condition, vst$type, sep="-")
> colnames(sampleDistMatrix) <- NULL
> colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
> pheatmap(sampleDistMatrix,
>          clustering_distance_rows=sampleDists,
>          clustering_distance_cols=sampleDists,
>          col=colors)
> ```
> {: .language-bash}
{: .solution}
